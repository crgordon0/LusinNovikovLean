/-
Copyright (c) 2024 Connor Gordon. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Connor Gordon
-/
import Mathlib.Topology.MetricSpace.Polish
import Mathlib.MeasureTheory.Constructions.Polish
import Mathlib.Topology.MetricSpace.CantorScheme
import Mathlib.Topology.Bases

/-!
# The Lusin-Novikov Theorem

In descriptive set theory, the Lusin-Novikov theorem is a dichotomy theorem that
has a few equivalent formulations. The statement of interest for this file is
that given a continuous function `f` between two Polish spaces `X` and `Y`
either one can partition the domain of `f` into countably many Borel sets on
which `f` is injective, or there exists a continuous injection from the Cantor
set (represented here as `ℕ → Bool`) into a single fiber of `f`.

This file aims to prove this theorem, following a proof by Forte Shinko using
sigma ideals.

## Main Definitions

* `BorelPartialSection s` : `s` is a Borel partial section of `f` if it is Borel
and the restriction of `f` to `s` is injective.
* `I f` : the sigma ideal generated by the Borel partial sections of `f`.
* `IsNull f F` : A `Finset` `F` of finite disjoint sets is null if there exists
a Borel cover `B` of `Y` indexed by `F` such that for each `s ∈ F`,
`s ∩ f ⁻¹' (B s) ∈ I f`.

## Implementation Notes

Due to the lack of infrastructure for sigma ideals in Mathlib, `I` has been
defined as a dual of a `CountableInterFilter` with some convenience lemmas
proved to avoid needing to directly refer to this definition.

## References

TO BE ADDED; Forte Shinko's paper and maybe Kechris's textbook if I end up
also formalizing some of the equivalent formulations from there

## Tags

lusin novikov, partial section
-/

namespace LusinNovikov

/- Let α and β be Measure spaces and suppose f is a measurable function between
them -/
variable {α : Type*} [mα : MeasurableSpace α]
variable {β : Type*} [mβ : MeasurableSpace β]
variable {f : α → β} (fmeas : Measurable f)

section SigmaIdeal

open Filter Classical Set

/-- A set `s` is a Borel partial section of `f` if it is Borel and the
restriction of `f` to `s` is injective.-/
def BorelPartialSection (f : α → β) (s : Set α) : Prop :=
  MeasurableSet s ∧ s.InjOn f

/-- We define the sigma ideal generated by Borel partial sections in three
phases. First, we consider the collection of complements of Borel partial
sections of `f` -/
def IDual0 (f : α → β) : Set (Set α) := {A : Set α | BorelPartialSection f Aᶜ}

/-- Now, we take the `CountableInterFilter` generated by this collection to get
the dual filter of our desired ideal -/
def IDual (f : α → β) : Filter α := countableGenerate (IDual0 f)

/-- Finally, we take the dual of this filter to get our desired sigma ideal -/
def I (f : α → β) : Set (Set α) := {s : Set α | sᶜ ∈ (IDual f)}

/-- Borel partial sections are contained in I -/
lemma borelpartialsection_mem_I (s : Set α) (hs : BorelPartialSection f s) :
  s ∈ I f := by
  rw[I, IDual, IDual0]
  simp only [Filter.mem_sets, mem_setOf_eq]
  rw[mem_countableGenerate_iff]
  use {sᶜ}
  simp only [singleton_subset_iff, mem_setOf_eq, compl_compl,
    countable_singleton, sInter_singleton,
    compl_subset_compl, true_and]
  exact ⟨hs, by apply Eq.subset rfl⟩

/-- I is closed under subsets -/
lemma subset_mem_I {s t : Set α} (ssubt : s ⊆ t) (ht : t ∈ I f) :
  s ∈ I f := by
  rw[I] at ht ⊢
  simp only [Filter.mem_sets, mem_setOf_eq] at ht ⊢
  rw [←compl_subset_compl] at ssubt
  exact mem_of_superset ht ssubt

/-- I is closed under finite unions -/
lemma union_mem_I {s t : Set α} (hs : s ∈ I f) (ht : t ∈ I f) :
  s ∪ t ∈ I f := by
  simp only [I._eq_1, Filter.mem_sets, mem_setOf_eq, compl_union,
    inter_mem_iff]
  exact ⟨hs, ht⟩

/-- I is closed under countable unions -/
lemma iUnion_mem_I (s : ℕ → Set α) :
  (⋃ n : ℕ, s n) ∈ I f ↔ ∀ n : ℕ, s n ∈ I f := by
  constructor
  . intro h
    rw[I] at h ⊢
    simp only [Filter.mem_sets, mem_setOf_eq] at h ⊢
    intro n
    rw[compl_iUnion] at h
    rw[←Filter.exists_mem_subset_iff]
    use (⋂ (i : ℕ), (s i)ᶜ)
    constructor
    . exact h
    apply iInter_subset
  intro h
  rw[I] at h ⊢
  simp only [Filter.mem_sets, mem_setOf_eq, compl_iUnion] at h ⊢
  rw[IDual, countable_iInter_mem]
  rw[IDual] at h
  exact h

/-- A set is in I if and only if it is contained in a countable union of Borel
partial sections of f -/
lemma mem_I_iff (s : Set α) : s ∈ I f ↔ ∃ S : Set (Set α),
  (∀ t ∈ S, BorelPartialSection f t) ∧ S.Countable ∧ s ⊆ ⋃₀ S := by
  rw[I, IDual]
  constructor
  . intro hs; rw[mem_setOf_eq] at hs
    rw[mem_countableGenerate_iff] at hs
    rcases hs with ⟨S, ⟨Ssub, Sctbl, hS⟩⟩
    use {tᶜ | t ∈ S}
    constructor
    . intro t ht; rw[mem_setOf_eq] at ht
      rcases ht with ⟨u, ⟨hu, hut⟩⟩
      specialize Ssub hu; rw[IDual0, mem_setOf_eq, hut] at Ssub
      exact Ssub
    constructor
    . rw[Set.countable_iff_exists_injOn] at Sctbl ⊢
      cases' Sctbl with f hf
      use fun t => f tᶜ
      intro t1 ht1 t2 ht2
      rw[mem_setOf_eq] at ht1 ht2
      rcases ht1 with ⟨u1, ⟨hu1, hu1t1⟩⟩
      rcases ht2 with ⟨u2, ⟨hu2, hu2t2⟩⟩
      simp only
      intro heq
      rw[←hu1t1, ←hu2t2]
      symm at hu1t1 hu2t2; rw[eq_compl_comm] at hu1t1 hu2t2
      rw[←hu1t1, ←hu2t2] at heq
      specialize hf hu1 hu2 heq
      exact congrArg compl hf
    intro x hx
    rw[subset_compl_comm] at hS
    simp only [mem_sUnion, mem_setOf_eq, exists_exists_and_eq_and,
      mem_compl_iff]
    specialize hS hx
    simp only [mem_compl_iff, mem_sInter, not_forall, exists_prop] at hS
    cases' hS with a ha
    use a
  intro h; rcases h with ⟨S, ⟨Sborel, Sctbl, Ssub⟩⟩
  rw[Set.mem_setOf_eq]
  rw[mem_countableGenerate_iff]
  use {t | tᶜ ∈ S}
  constructor
  . intro t ht
    rw[mem_setOf_eq] at ht
    specialize Sborel tᶜ ht
    rw[IDual0, Set.mem_setOf_eq]
    exact Sborel
  constructor
  . rw[Set.countable_iff_exists_injOn] at Sctbl ⊢
    cases' Sctbl with f hf
    use fun t => f tᶜ
    intro t1 ht1 t2 ht2
    rw[mem_setOf_eq] at ht1 ht2
    simp only
    intro heq
    specialize hf ht1 ht2 heq
    rw[←compl_compl t1, ←compl_compl t2]
    exact congrArg compl hf
  rw[←compl_subset_compl, compl_sUnion, sInter_image] at Ssub
  have : ⋂ x ∈ S, xᶜ = ⋂₀ {t | tᶜ ∈ S} := by
    ext x;
    simp only [mem_iInter, mem_compl_iff, mem_sInter, mem_setOf_eq]
    constructor
    . intro hx t ht
      specialize hx tᶜ ht
      exact Set.not_mem_compl_iff.mp hx
    intro hx t ht
    rw[←compl_compl t] at ht
    specialize hx tᶜ ht
    exact hx
  rw[this] at Ssub; exact Ssub







end SigmaIdeal

section Null

open Filter Classical Set

/-- A family of sets in a topological space indexed by a Finset is a Borel
cover if each set in the family is Borel and the union of the family is the
entire space -/
def FBorelCover (B : Set α → Set β) (F : Finset (Set α)) :=
  ⋃ s ∈ F, B s = univ ∧ ∀ s ∈ F, MeasurableSet (B s)

/-- A family of sets in a topological space indexed by ℕ is a Borel
cover if each set in the family is Borel and the union of the family is the
entire space -/
def BorelCover (B : ℕ → Set β) :=
  ⋃ n : ℕ, B n = univ ∧ ∀ n : ℕ, MeasurableSet (B n)

/-- A family of sets in a topological space is null if there exists a Borel
cover B of Y indexed by F such that for each s ∈ F,
s ∩ f ⁻¹' (B s) ∈ I f -/
def IsNull (f : α → β) (F : Finset (Set α)) : Prop :=
  ∃ B : Set α → Set β, FBorelCover B F ∧ ∀ s ∈ F, s ∩ f ⁻¹' (B s) ∈ I f

/-- A singleton family is null if and only if its element is in I -/
lemma null_sing_iff_in_I (u : Set α) : IsNull f {u} ↔ u ∈ I f := by
  constructor
  . intro hF
    rw[IsNull] at hF
    rcases hF with ⟨B, ⟨BBorel, Bpre⟩⟩
    rw[FBorelCover] at BBorel
    have huniv := BBorel.1
    simp only [Finset.mem_singleton, iUnion_iUnion_eq_left] at huniv
    simp only [Finset.mem_singleton, forall_eq] at Bpre
    rw[huniv] at Bpre
    simp only [preimage_univ, inter_univ] at Bpre
    exact Bpre
  intro hu
  rw[IsNull]
  let B : Set α → Set β := fun C => if C = u then univ else ∅
  use B
  constructor
  . rw[FBorelCover]
    constructor
    . ext x
      constructor
      . intro _
        trivial
      intro _
      rw [mem_iUnion]
      use u
      simp only [B, Finset.mem_singleton, ite_true, iUnion_true, mem_univ]
    simp only [B, Finset.mem_singleton, forall_eq, ite_true, MeasurableSet.univ]
  simp only [B, Finset.mem_singleton, forall_eq, ite_true, preimage_univ,
    inter_univ]
  exact hu

/-- All sets in a non-null family are nonempty -/
lemma nonempty_of_nonnull (Fnonnull : ¬IsNull f F) : ∀ s ∈ F,
  Set.Nonempty s := by
    intro s hs
    rw[Set.nonempty_iff_ne_empty]
    intro hcont
    apply Fnonnull
    rw[IsNull]
    let B (s : Set α) : Set β := if s = ∅ then univ else ∅
    have B_def : ∀ s : Set α, B s = if s = ∅ then univ else ∅ := by intro s; rfl
    use B
    constructor
    . rw [FBorelCover]
      constructor
      . ext x
        constructor
        . intro _
          trivial
        intro _
        rw [mem_iUnion]
        use s
        simp only [B, mem_iUnion, mem_ite_empty_right, mem_univ,
          and_true, exists_prop]
        exact ⟨hs, hcont⟩
      intro _ _
      rw [B_def]
      split
      . simp only [MeasurableSet.univ]
      simp only [MeasurableSet.empty]
    intro _ _
    rw[B_def]
    split
    . next he =>
      rw [he, I]
      simp only [preimage_univ, inter_univ, Filter.mem_sets,
        mem_setOf_eq, compl_empty, univ_mem]
    rw[I]
    simp only [preimage_empty, inter_empty, Filter.mem_sets,
      mem_setOf_eq, compl_empty, univ_mem]

/- Given a set s in X, (s)² is the set of all points (x,y) ∈ s² with x ≠ y. -/
def sq_minus_diag (s : Set α) := {x : α × α | x.1 ∈ s ∧ x.2 ∈ s ∧ x.1 ≠ x.2}

/- Lemma 1: Let F be a finite disjoint collection of sets in α, and suppose u
is another Borel set not in F that is disjoint from everything in F. Further
suppose that we can decompose (u)² = ⋃ n : ℕ, (v n × w n) for sets v n and w n.
If each F ⊔ {v n, w n} is null, then so is F ⊔ {u}. -/

/- After fixing Borel covers B n witnessing each F ⊔ {v n, w n} being null, we
first prove Lemma 1 under the further assumption that each B n s is equal for
all n : ℕ, s ∈ F and that B v n and B w n are disjoint from B n s for all n :
ℕ, s ∈ F. -/
lemma null_of_decomp_null_with_common_disjoint_cover
  {F : Finset (Set α)} {u : Set α} {v w : ℕ → Set α} {B : ℕ → Set α → Set β}
  (huborel : MeasurableSet u) (huninF : u ∉ F)
  (hdecomp : sq_minus_diag u = ⋃ n : ℕ, v n ×ˢ w n)
  (hvborel : ∀ n : ℕ, MeasurableSet (v n))
  (hwborel : ∀ n : ℕ, MeasurableSet (w n))
  (hBdisjv : ∀ n : ℕ, ∀ s ∈ F, Disjoint (B n s) (B n (v n)))
  (hBdisjw : ∀ n : ℕ, ∀ s ∈ F, Disjoint (B n s) (B n (w n)))
  (hBcover : ∀ n : ℕ, FBorelCover (B n) (F ∪ {v n, w n}))
  (hBnull : ∀ n : ℕ, ∀ s ∈ F ∪ {v n, w n}, s ∩ f ⁻¹' (B n s) ∈ I f)
  (hBcommon : ∀ n : ℕ, ∀ s ∈ F, B n s = B 0 s)
  : IsNull f (F ∪ {u}) := by
    rw[IsNull]
    let u1 := (⋃ s ∈ F, B 0 s)ᶜ
    let B' (s : Set α) := if s = u then u1 else (B 0 s)
    use B'
    constructor
    . rw[FBorelCover]
      constructor
      . ext x
        constructor
        intro _; trivial
        intro _
        rw[Set.mem_iUnion]
        by_cases h : x ∈ u1
        . use u
          simp only [B', Finset.mem_union, Finset.mem_singleton, or_true,
            Set.compl_iUnion, ite_true, Set.iUnion_true,
            Set.mem_iInter, Set.mem_compl_iff]
          simp only [Set.compl_iUnion, Set.mem_iInter, Set.mem_compl_iff] at h
          exact h
        simp only [u1, B', Set.compl_iUnion, Set.mem_iInter, Set.mem_compl_iff,
          not_forall, not_not, exists_prop] at h
        rcases h with ⟨s, ⟨hsF, hs⟩⟩
        use s
        simp only [B', Finset.mem_union, Finset.mem_singleton, Set.compl_iUnion,
          Set.mem_iUnion, exists_prop]
        constructor
        exact Or.inl hsF
        split
        next hsu =>
          exfalso
          rw[←hsu] at huninF
          exact huninF hsF
        exact hs
      intro s hs
      simp only [B', u1, Set.compl_iUnion]
      split
      . apply Finset.measurableSet_biInter
        intro t ht
        apply MeasurableSet.compl
        apply (hBcover 0).2
        rw[Finset.mem_union]
        exact Or.inl ht
      next hsu =>
        apply (hBcover 0).2
        rw[Finset.mem_union, Finset.mem_singleton] at hs
        rcases hs with hs | hs
        rw[Finset.mem_union]; exact Or.inl hs
        exfalso; exact hsu hs
    intro s hs
    rw[Finset.mem_union, Finset.mem_singleton] at hs
    rcases hs with hs | hs
    . simp only [B', u1, Set.compl_iUnion]
      split
      next h => exfalso; rw[←h] at huninF; exact huninF hs
      apply hBnull 0; rw[Finset.mem_union]; exact Or.inl hs
    rw[hs]
    set u2 := ⋃ n : ℕ, ((v n ∩ f ⁻¹' B n (v n)) ∪ (w n ∩ f ⁻¹' B n (w n)))
    have hsub : u ∩ f ⁻¹' B' u ⊆ ((u ∩ f⁻¹' B' u) ∩ u2ᶜ) ∪ u2 := by
      intro x hx
      by_cases h : x ∈ u2
      apply Set.mem_union_right; exact h
      apply Set.mem_union_left
      apply Set.mem_inter
      exact hx
      apply Set.mem_compl; exact h
    apply subset_mem_I hsub
    have hB'u : ∀ n : ℕ, B' u = B n (v n) ∪ B n (w n) := by
      intro n; ext x; constructor
      . intro hx
        simp only [B', u1, Set.compl_iUnion, ite_true, Set.mem_iInter,
          Set.mem_compl_iff] at hx
        have hxuniv : x ∈ Set.univ := by trivial
        rw[←(hBcover n).1] at hxuniv
        simp only [Finset.mem_singleton, Finset.union_insert, Finset.mem_union,
          Finset.mem_insert, Set.iUnion_iUnion_eq_or_left, Set.mem_union,
          Set.mem_iUnion, exists_prop] at hxuniv
        rcases hxuniv with hxv | hxw
        apply Set.mem_union_left; exact hxv
        rcases hxw with ⟨s, ⟨hs | hs, hxs⟩⟩
        exfalso; rw[hBcommon n s hs] at hxs; exact (hx s hs) hxs
        rw[hs] at hxs; rw[Set.mem_union]; exact Or.inr hxs
      intro hx
      simp only [B', u1, Set.compl_iUnion, ite_true, Set.mem_iInter, Set.mem_compl_iff]
      intro s hs
      rw[Set.mem_union] at hx
      rcases hx with hxv | hxw
      . intro hcont
        rw[←hBcommon n s hs] at hcont
        have hcont := Set.mem_inter hcont hxv
        have := hBdisjv n s hs
        rw[Set.disjoint_iff_inter_eq_empty] at this
        rw[this] at hcont
        exact hcont
      . intro hcont
        rw[←hBcommon n s hs] at hcont
        have hcont := Set.mem_inter hcont hxw
        have := hBdisjw n s hs
        rw[Set.disjoint_iff_inter_eq_empty] at this
        rw[this] at hcont
        exact hcont
    apply union_mem_I
    apply borelpartialsection_mem_I
    constructor
    . apply MeasurableSet.inter
      . apply MeasurableSet.inter
        exact huborel
        apply measurableSet_preimage
        . exact fmeas
        rw[(hB'u 0)]
        apply MeasurableSet.union
        apply (hBcover 0).2 (v 0); simp
        apply (hBcover 0).2 (w 0); simp
      apply MeasurableSet.compl
      apply MeasurableSet.iUnion
      intro n
      apply MeasurableSet.union
      . apply MeasurableSet.inter
        exact hvborel n
        apply measurableSet_preimage
        . exact fmeas
        apply (hBcover n).2; simp
      apply MeasurableSet.inter
      exact hwborel n
      apply measurableSet_preimage
      . exact fmeas
      apply (hBcover n).2; simp
    . intro xv hxv xw hxw
      contrapose
      intro hneq hfeq
      have memdecomp : ∃ n : ℕ, xv ∈ (v n) ∧ xw ∈ (w n) := by
        have memdiag : (xv, xw) ∈ sq_minus_diag u := by
          rw[sq_minus_diag]
          simp only [ne_eq, Set.mem_setOf_eq]
          rw[Set.mem_inter_iff, Set.mem_inter_iff] at hxv hxw
          exact ⟨hxv.1.1, hxw.1.1, hneq⟩
        rw[hdecomp] at memdiag
        simp only [Set.mem_iUnion, Set.mem_prod] at memdiag
        exact memdiag
      rcases memdecomp with ⟨n, ⟨hvn, hwn⟩⟩
      have fxvU : f xv ∈ B' u := by
        simp only [B', u1, Set.compl_iUnion, ite_true, Set.mem_iInter,
          Set.mem_compl_iff]
        intro t ht
        simp only [B', u1, Set.compl_iUnion, ite_true, Set.compl_union,
          Set.mem_inter_iff, Set.mem_preimage, Set.mem_iInter,
          Set.mem_compl_iff, not_and] at hxv
        exact hxv.1.2 t ht
      rw[hB'u n] at fxvU
      rcases fxvU with fxvv | fxvw
      . have hcont : xv ∈ (v n) ∩ f ⁻¹' (B n (v n)) := by
          apply Set.mem_inter; exact hvn; rw[Set.mem_preimage]; exact fxvv
        simp only [B', u1, u2, Set.compl_iUnion, ite_true, Set.compl_union,
          Set.mem_inter_iff, Set.mem_preimage, Set.mem_iInter,
          Set.mem_compl_iff, not_and] at hxv
        exact (hxv.2 n).1 hcont.1 fxvv
      have hcont : xw ∈ (w n) ∩ f ⁻¹' (B n (w n)) := by
        apply Set.mem_inter; exact hwn; rw[Set.mem_preimage, ←hfeq]; exact fxvw
      have hcont : xw ∈ u2 := by
        simp only [u2, Set.mem_iUnion, Set.mem_union, Set.mem_inter_iff,
          Set.mem_preimage]
        use n
        rw[Set.mem_inter_iff, Set.mem_preimage] at hcont
        exact Or.inr hcont
      rw[Set.mem_inter_iff, Set.mem_compl_iff] at hxw
      exact hxw.2 hcont
    rw[iUnion_mem_I]
    intro n
    apply union_mem_I
    apply hBnull n; simp
    apply hBnull n; simp

/- We then prove that general case of Lemma 1. -/
lemma null_of_decomp_null
  {F : Finset (Set α)} {u : Set α} {v w : ℕ → Set α}
  (huborel : MeasurableSet u) (huninF : u ∉ F)
  (hdecomp : sq_minus_diag u = ⋃ n : ℕ, v n ×ˢ w n)
  (hvninF : ∀ n : ℕ, v n ∉ F) (hwninF : ∀ n : ℕ, w n ∉ F)
  (hvnew : ∀ n : ℕ, v n ≠ w n)
  (hvborel : ∀ n : ℕ, MeasurableSet (v n))
  (hwborel : ∀ n : ℕ, MeasurableSet (w n))
  (hvwnull : ∀ n : ℕ, IsNull f (F ∪ {v n, w n}))
  : IsNull f (F ∪ {u}) := by
    choose B0 hB0cover hB0null using
      fun n => hvwnull n
    let B1 (n : ℕ) (s : Set α) := if s ∈ F then ⋃ m : ℕ, B0 m s else B0 n s
    have hB1cover : ∀ n : ℕ, FBorelCover (B1 n) (F ∪ {v n, w n}) := by
      intro n; constructor
      . ext x; constructor
        intro _; trivial
        intro hx
        rw[←(hB0cover n).1] at hx
        rw[Set.mem_iUnion] at hx
        cases' hx with s hx
        rw[Set.mem_iUnion] at hx
        cases' hx with hs hx
        rw[Set.mem_iUnion]
        use s
        rw[Set.mem_iUnion]
        use hs
        simp only [B1]
        split
        rw[Set.mem_iUnion]; use n
        exact hx
      intro s hs
      simp only [B1]; split
      next h =>
        apply MeasurableSet.iUnion
        intro m
        apply (hB0cover m).2 s
        rw[Finset.mem_union]
        exact Or.inl h
      exact (hB0cover n).2 s hs
    have hB1null : ∀ (n : ℕ) (C : Set α), C ∈ F ∪ {v n, w n} →
      C ∩ f ⁻¹' B1 n C ∈ I f := by
        intro n s hs
        simp only [B1]
        split
        next h =>
          rw[Set.preimage_iUnion, Set.inter_iUnion, iUnion_mem_I]
          intro m
          apply hB0null m
          rw[Finset.mem_union]
          exact Or.inl h
        exact hB0null n s hs
    let uv (n : ℕ) := B1 n (v n) ∩ (⋃ s ∈ F, B1 n s)ᶜ
    let uw (n : ℕ) := B1 n (w n) ∩ (⋃ s ∈ F, B1 n s)ᶜ
    let B (n : ℕ) (s : Set α) := if s = v n then uv n else if s = w n then uw n
      else B1 n s
    have hBeq : ∀ n : ℕ, ∀ s, B n s = if s = v n then uv n else if s = w n
      then uw n else B1 n s := by intro n s; simp only
    have hBcommon : ∀ n : ℕ, ∀ s ∈ F, B n s = B 0 s := by
      intro n s hs
      have snev : s ≠ v n := by
        intro hcont; rw[hcont] at hs; exact hvninF n hs
      have snew : s ≠ w n := by
        intro hcont; rw[hcont] at hs; exact hwninF n hs
      have snev0 : s ≠ v 0 := by
        intro hcont; rw[hcont] at hs; exact hvninF 0 hs
      have snew0 : s ≠ w 0 := by
        intro hcont; rw[hcont] at hs; exact hwninF 0 hs
      simp only [B, B1]
      rw[if_neg snev, if_neg snew, if_neg snev0, if_neg snew0, if_pos hs, if_pos hs]
    have hBcover : ∀ n : ℕ, FBorelCover (B n) (F ∪ {v n, w n}) := by
      intro n; constructor
      . ext x; constructor
        intro _; trivial
        intro hx
        rw[←(hB1cover n).1] at hx
        by_cases h : x ∈ ⋃ C ∈ F, B1 n C
        . rw[Set.mem_iUnion] at h
          cases' h with s hs
          rw[Set.mem_iUnion] at hs
          cases' hs with hsF hs
          rw[Set.mem_iUnion]
          use s
          rw[Set.mem_iUnion]
          have : s ∈ F ∪ {v n, w n} := by rw[Finset.mem_union]; exact Or.inl hsF
          use this
          have snev : s ≠ v n := by
            intro hcont; rw[hcont] at hsF; exact hvninF n hsF
          have snew : s ≠ w n := by
            intro hcont; rw[hcont] at hsF; exact hwninF n hsF
          rw[hBeq]
          rw[if_neg snev, if_neg snew]
          exact hs
        rw[Set.mem_iUnion] at hx
        cases' hx with s hs
        rw[Set.mem_iUnion] at hs
        cases' hs with hsF hs
        have : s ∉ F := by
          intro hcont
          apply h
          rw[Set.mem_iUnion]
          use s
          rw[Set.mem_iUnion]
          use hcont
        simp only [Finset.mem_singleton, Finset.union_insert, Finset.mem_union,
          Finset.mem_insert] at hsF
        rcases hsF with hsv | hsF | hsw
        . rw[Set.mem_iUnion]
          use s
          rw[Set.mem_iUnion]
          have : s ∈ F ∪ {v n, w n} := by
            simp only [Finset.mem_singleton, Finset.union_insert,
              Finset.mem_union, Finset.mem_insert]
            exact Or.inl hsv
          use this
          rw[hBeq, if_pos hsv, Set.mem_inter_iff, ←hsv]
          exact ⟨hs, h⟩
        exfalso; exact this hsF
        rw[Set.mem_iUnion]
        use s
        rw[Set.mem_iUnion]
        have : s ∈ F ∪ {v n, w n} := by
          simp only [Finset.mem_singleton, Finset.union_insert,
            Finset.mem_union, Finset.mem_insert]
          exact Or.inr (Or.inr hsw)
        use this
        rw[hBeq, if_neg, if_pos hsw, Set.mem_inter_iff, ←hsw]
        exact ⟨hs, h⟩
        rw[hsw]; exact (hvnew n).symm
      intro s hs
      rw[hBeq]
      split
      . apply MeasurableSet.inter
        apply (hB1cover n).2;
        simp only [Finset.mem_singleton, Finset.union_insert, Finset.mem_union,
          Finset.mem_insert, true_or]
        apply MeasurableSet.compl
        apply Finset.measurableSet_biUnion
        intro t ht
        apply (hB1cover n).2
        rw[Finset.mem_union]
        exact Or.inl ht
      split
      . apply MeasurableSet.inter
        apply (hB1cover n).2;
        simp only [Finset.mem_singleton, Finset.union_insert, Finset.mem_union,
          Finset.mem_insert, or_true]
        apply MeasurableSet.compl
        apply Finset.measurableSet_biUnion
        intro t ht
        apply (hB1cover n).2
        rw[Finset.mem_union]
        exact Or.inl ht
      exact (hB1cover n).2 s hs
    have hBnull : ∀ n : ℕ, ∀ C ∈ (F ∪ {v n, w n}), C ∩ f ⁻¹' B n C ∈ I f := by
      intro n s hs
      apply subset_mem_I _ (hB1null n s hs)
      apply Set.inter_subset_inter_right
      apply Set.preimage_mono
      intro x hx
      rw[hBeq] at hx
      split at hx
      next h => rw[h]; apply Set.mem_of_mem_inter_left; exact hx
      split at hx
      next _ h => rw[h]; apply Set.mem_of_mem_inter_left; exact hx
      exact hx
    have hBdisjv : ∀ n : ℕ, ∀ s ∈ F, Disjoint (B n s) (B n (v n)) := by
      intro n s hs
      have snev : s ≠ v n := by
        intro hcont; rw[hcont] at hs; exact hvninF n hs
      have snew : s ≠ w n := by
        intro hcont; rw[hcont] at hs; exact hwninF n hs
      rw[Set.disjoint_iff]
      intro x hx
      rw[hBeq, hBeq, if_neg snev, if_neg snew, if_pos rfl] at hx
      rcases hx with ⟨hxs, _, hxns⟩
      rw[Set.mem_compl_iff] at hxns
      apply hxns
      rw[Set.mem_iUnion]
      use s
      rw[Set.mem_iUnion]
      use hs
    have hBdisjw : ∀ n : ℕ, ∀ s ∈ F, Disjoint (B n s) (B n (w n)) := by
      intro n s hs
      have snev : s ≠ v n := by
        intro hcont; rw[hcont] at hs; exact hvninF n hs
      have snew : s ≠ w n := by
        intro hcont; rw[hcont] at hs; exact hwninF n hs
      rw[Set.disjoint_iff]
      intro x hx
      rw[hBeq, hBeq, if_neg snev, if_neg snew, if_neg (hvnew n).symm,
        if_pos rfl] at hx
      rcases hx with ⟨hxs, _, hxns⟩
      rw[Set.mem_compl_iff] at hxns
      apply hxns
      rw[Set.mem_iUnion]
      use s
      rw[Set.mem_iUnion]
      use hs
    exact null_of_decomp_null_with_common_disjoint_cover fmeas huborel huninF hdecomp hvborel hwborel hBdisjv hBdisjw hBcover hBnull hBcommon

/- Lemma 2 : Let F be a finite disjoint collection of sets in α, and suppose
(v n | n : ℕ) is a Borel cover of β. If for all n, the family
(s ∩ f ⁻¹' (a n) | s ∈ F) is null, then F is null. -/
lemma null_of_localizations_null
  {F : Finset (Set α)} {v : ℕ → Set β} (hvcover : BorelCover v)
  (hvnull : ∀ n : ℕ, IsNull f (F.image fun C => C ∩ f⁻¹' (v n)))
  : IsNull f F := by
    choose B0 hB0cover hB0null using
      fun n => hvnull n
    let B (n : ℕ) (s : Set α) := B0 n (s ∩ f ⁻¹' (v n))
    have hBcover : ∀ n : ℕ, FBorelCover (B n) F := by
      intro n
      constructor
      . ext x; constructor
        intro _; trivial
        intro hx
        rw[←(hB0cover n).1] at hx
        rw[Set.mem_iUnion] at hx
        cases' hx with s hs
        rw[Set.mem_iUnion] at hs
        cases' hs with hs hx
        rw[Finset.mem_image] at hs
        cases' hs with t ht
        rw[Set.mem_iUnion]
        use t
        rw[Set.mem_iUnion]
        use ht.1
        simp only [B]
        rw[ht.2]
        exact hx
      intro s hs
      apply (hB0cover n).2
      rw[Finset.mem_image]
      use s
    have hBnull : ∀ n : ℕ, ∀ s ∈ F, s ∩ f ⁻¹' v n ∩ f ⁻¹' B n s ∈ I f := by
      intro n s hs
      apply hB0null n
      rw[Finset.mem_image]
      use s
    use fun s => ⋃ n : ℕ, (v n ∩ B n s)
    constructor
    . constructor
      . ext x; constructor
        intro _; trivial
        intro hx
        have hxcopy := hx
        rw[←hvcover.1, Set.mem_iUnion] at hx
        cases' hx with n hn
        rw[←(hBcover n).1, Set.mem_iUnion] at hxcopy
        cases' hxcopy with s hs
        rw[Set.mem_iUnion] at hs
        cases' hs with hs hx
        rw[Set.mem_iUnion]
        use s
        rw[Set.mem_iUnion]
        use hs
        rw[Set.mem_iUnion]
        use n
        rw[Set.mem_inter_iff]
        exact ⟨hn, hx⟩
      intro s hs
      apply MeasurableSet.iUnion
      intro n
      apply MeasurableSet.inter
      exact hvcover.2 n
      exact (hBcover n).2 s hs
    intro s hs
    rw[Set.preimage_iUnion, Set.inter_iUnion, iUnion_mem_I]
    intro n
    rw[Set.preimage_inter, ←Set.inter_assoc]
    exact hBnull n s hs

end Null

/- From here on out, we assume that α and β are separable metric spaces -/
variable [mα : MetricSpace α] [sα : TopologicalSpace.SeparableSpace α]
variable [mβ : MetricSpace β] [sβ : TopologicalSpace.SeparableSpace β]

section Topology

open TopologicalSpace Bornology

/- Observation 1 : Given a closed u in α and ε > 0, we can find closed disjoint
sets (v n | n : ℕ) and (w n | n : ℕ) of diameter ≤ 2ε such that
(u)² = ⋃ n : ℕ, v n ×ˢ w n. -/
lemma ediam_diam_aux {u : Set α} (ubdd : IsBounded u) : EMetric.diam u =
  ENNReal.ofReal (Metric.diam u) := by
    have : EMetric.diam u ≠ ⊤ := by
      rw[ne_eq, Metric.ediam_eq_top_iff_unbounded, not_not]
      exact ubdd
    unfold Metric.diam
    rw [ENNReal.ofReal_toReal this]

lemma decomp_of_sq_minus_diag_u_real {u : Set α} {ε : ℝ} (uclosed : IsClosed u)
  (unonempty : Set.Nonempty u) (εpos : ε > 0)
  : ∃ v : ℕ → Set α, ∃ w : ℕ → Set α,
  sq_minus_diag u = ⋃ n : ℕ, v n ×ˢ w n
  ∧ (∀ n : ℕ, (v n) ⊆ u) ∧ (∀ n : ℕ, (w n) ⊆ u)
  ∧ (∀ n : ℕ, IsClosed (v n)) ∧ (∀ n : ℕ, IsClosed (w n))
  ∧ (∀ n : ℕ, IsBounded (v n))
  ∧ (∀ n : ℕ, IsBounded (w n))
  ∧ (∀ n : ℕ, Metric.diam (v n) ≤ ε)
  ∧ (∀ n : ℕ, Metric.diam (w n) ≤ ε)
  ∧ (∀ n : ℕ, v n ≠ w n)
  := by
    -- Pick a point in u (to be used later)
    have unonempty' := unonempty
    choose x0 hx0 using unonempty'
    -- Prove u is separable
    have Usep : SeparableSpace u := by
      apply IsSeparable.separableSpace
      rw[IsSeparable]
      choose D Dctbl Ddense using exists_countable_dense α
      use D
      constructor
      exact Dctbl
      unfold Dense at Ddense
      intro x _
      exact Ddense x
    -- Pick a dense sequence from u
    have unonempty : Nonempty u := by
      rw[Set.nonempty_iff_ne_empty', ←Set.nonempty_iff_ne_empty]
      exact unonempty
    choose D Ddense using exists_dense_seq u
    have dist_coer : ∀ i j, dist (D i) (D j) = dist (D i : α) (D j) := fun i j => rfl
    let v (n : ℕ × ℕ) : Set α := if dist (D n.1) (D n.2) = 0 then ∅ else
      u ∩ Metric.closedBall (D n.1) (min (ε/2) (1/3 * dist (D n.1) (D n.2)))
    let w (n : ℕ × ℕ) : Set α := if dist (D n.1) (D n.2) = 0 then {x0} else
      u ∩ Metric.closedBall (D n.2) (min (ε/2) (1/3 * dist (D n.1) (D n.2)))
    have hdecomp : ⋃ n : ℕ × ℕ, v n ×ˢ w n = sq_minus_diag u := by
      ext x; constructor
      -- Prove the forward containment
      . intro hx
        rw[Set.mem_iUnion] at hx
        cases' hx with i hi
        simp only [v, w] at hi; split at hi
        . simp only [Set.empty_prod, Set.mem_empty_iff_false] at hi
        simp only [Set.mem_inter_iff, ge_iff_le, Set.mem_prod, Set.mem_inter_iff,
          Metric.mem_closedBall, le_min_iff] at hi
        simp only [sq_minus_diag, ne_eq, Set.mem_setOf_eq]
        constructor; exact hi.1.1; constructor; exact hi.2.1
        rw[←dist_eq_zero]
        intro hdist
        have hcont := dist_triangle4 (D i.1 : α) x.1 x.2 (D i.2)
        rw [hdist] at hcont
        have hcont2 := add_le_add hi.1.2.2 hi.2.2.2
        simp only [add_zero] at hcont hcont2
        rw[dist_comm] at hcont2
        have hcont3 := le_trans hcont hcont2
        ring_nf at hcont3
        rw[dist_coer i.1 i.2, le_mul_iff_one_le_right] at hcont3
        norm_num at hcont3
        apply lt_of_le_of_ne
        exact dist_nonneg
        rw[ne_eq, eq_comm]; next h => exact h
      -- Setting up things for the backward containment
      intro hx
      simp only [sq_minus_diag, ne_eq, Set.mem_setOf_eq] at hx
      rcases hx with ⟨hx1, hx2, hne⟩
      set r := dist x.1 x.2
      have : min (ε/2) (r/6) > 0 := by
        apply lt_min
        simp only [gt_iff_lt, Nat.ofNat_pos, div_pos_iff_of_pos_right, εpos]
        simp only [gt_iff_lt, Nat.ofNat_pos, div_pos_iff_of_pos_right]
        rw[←ne_eq, ←dist_ne_zero] at hne
        apply lt_of_le_of_ne
        exact dist_nonneg
        exact hne.symm
      rw[Metric.denseRange_iff] at Ddense
      -- Obtain the sets our given point is going to be in
      choose a ha using Ddense ⟨x.1, hx1⟩ (min (ε/2) (r/6)) this
      choose b hb using Ddense ⟨x.2, hx2⟩ (min (ε/2) (r/6)) this
      rw[Set.mem_iUnion]
      use (a,b)
      -- Show that D a and D b are different because x.1 and x.2 are too far apart
      have hab : D a ≠ D b := by
        intro heq
        rw[←zero_eq_dist] at heq
        have hcont := dist_triangle4 x.1 (D a : α) (D b) x.2
        have : dist x.1 x.2 ≤ 2/6 * dist x.1 x.2 := by
          apply le_trans hcont _
          have aux1 : dist x.1 (D a : α) ≤ r/6 := by
            exact le_trans (le_of_lt ha) (min_le_right _ _)
          have aux2 : dist (D a : α) (D b) ≤ 0 := le_of_eq heq.symm
          have aux3 : dist (D b : α) x.2 ≤ r/6 := by
            rw[dist_comm]
            exact le_trans (le_of_lt hb) (min_le_right _ _)
          have ineq2 := add_le_add (add_le_add aux1 aux2) aux3
          apply le_trans ineq2 _
          apply le_of_eq
          ring_nf
        rw[le_mul_iff_one_le_left] at this
        norm_num at this
        rw[←ne_eq, ←dist_ne_zero] at hne
        apply lt_of_le_of_ne
        exact dist_nonneg
        exact hne.symm
      -- Start proving the containment
      constructor
      -- Prove x.1 is in v (a,b)
      . simp only [dist_eq_zero, Set.mem_ite_empty_left, Set.mem_inter_iff,
          Metric.mem_closedBall, le_min_iff, v]
        constructor; exact hab
        constructor; exact hx1
        constructor; exact le_trans (le_of_lt ha) (min_le_left _ _)
        apply le_of_not_gt
        intro hdist; rw[gt_iff_lt] at hdist
        have hdist : dist (D a) (D b) ≤ 3 * dist x.1 (D a) := by
          linarith
        have hcont := dist_triangle4 x.1 (D a) (D b) x.2
        have : dist x.1 x.2 ≤ 5/6 * dist x.1 x.2 := by
          apply le_trans hcont
          have aux1 : dist x.1 (D a) ≤ r/6 := by
            exact le_trans (le_of_lt ha) (min_le_right _ _)
          have aux2 : dist (D a) (D b) ≤ 3 * r/6 := by
            apply le_trans hdist
            rw[mul_div_assoc]
            apply mul_le_mul
            norm_num
            exact aux1
            exact dist_nonneg
            norm_num
          have aux3 : dist (D b : α) x.2 ≤ r/6 := by
            rw[dist_comm]; exact le_trans (le_of_lt hb) (min_le_right _ _)
          have ineq2 := add_le_add (add_le_add aux1 aux2) aux3
          apply le_trans ineq2 _
          ring_nf
          apply le_of_eq
          rfl
        rw[le_mul_iff_one_le_left] at this
        norm_num at this
        rw[←ne_eq, ←dist_ne_zero] at hne
        apply lt_of_le_of_ne
        exact dist_nonneg
        exact hne.symm
      -- Prove x.2 is in w
      rw[ne_eq, ←dist_eq_zero] at hab
      simp only [w]
      rw[if_neg hab, Set.mem_inter_iff, Metric.mem_closedBall, le_min_iff]
      constructor; exact hx2
      constructor; exact le_trans (le_of_lt hb) (min_le_left _ _)
      apply le_of_not_gt
      intro hdist; rw[gt_iff_lt] at hdist
      have hdist : dist (D a) (D b) ≤ 3 * dist x.2 (D b) := by
        linarith
      have hcont := dist_triangle4 x.1 (D a) (D b) x.2
      have : dist x.1 x.2 ≤ 5/6 * dist x.1 x.2 := by
        apply le_trans hcont
        have aux1 : dist (D b : α) x.2 ≤ r/6 := by
          rw[dist_comm]; exact le_trans (le_of_lt hb) (min_le_right _ _)
        have aux2 : dist (D a) (D b) ≤ 3 * r/6 := by
          apply le_trans hdist
          rw[mul_div_assoc, dist_comm]
          apply mul_le_mul
          norm_num
          exact aux1
          exact dist_nonneg
          norm_num
        have aux3 : dist x.1 (D a) ≤ r/6 := by
          exact le_trans (le_of_lt ha) (min_le_right _ _)
        have ineq2 := add_le_add (add_le_add aux3 aux2) aux1
        apply le_trans ineq2 _
        ring_nf
        apply le_of_eq
        rfl
      rw[le_mul_iff_one_le_left] at this
      norm_num at this
      rw[←ne_eq, ←dist_ne_zero] at hne
      apply lt_of_le_of_ne
      exact dist_nonneg
      exact hne.symm
    -- Define the actual covers we'll be using
    let v' (n : ℕ) : Set α := v (Nat.unpair n)
    let w' (n : ℕ) : Set α := w (Nat.unpair n)
    use v'
    use w'
    constructor
    -- Prove the decomposition works
    . rw[←hdecomp]
      ext x; constructor
      . intro hx
        rw[Set.mem_iUnion] at hx ⊢
        cases' hx with n hn
        use Nat.pair n.1 n.2
        simp only [v, w, v', w', Nat.unpair_pair] at hn ⊢
        exact hn
      intro hx
      rw[Set.mem_iUnion] at hx ⊢
      cases' hx with n hn
      use Nat.unpair n
    constructor
    -- Prove v' n ⊆ u
    . intro n; simp only [v, v']; split
      exact Set.empty_subset _
      exact Set.inter_subset_left _ _
    constructor
    -- Prove w' n ⊆ u
    . intro n; simp only [w, w']; split
      intro x hx; rw[Set.mem_singleton_iff] at hx; rw[hx]; exact hx0
      exact Set.inter_subset_left _ _
    constructor
    -- Prove v' n is closed
    . intro n; simp only [v, v']; split
      exact isClosed_empty
      apply IsClosed.inter
      exact uclosed
      exact Metric.isClosed_ball
    constructor
    -- Prove w' n is closed
    . intro n; simp only [w, w']; split
      exact T1Space.t1 x0
      apply IsClosed.inter
      exact uclosed
      exact Metric.isClosed_ball
    constructor
    -- Prove v' n is bounded
    . intro n; simp only [v', v]; split
      exact isBounded_empty
      apply IsBounded.subset Metric.isBounded_closedBall
      exact Set.inter_subset_right _ _
    constructor
    -- Prove w' n is bounded
    . intro n; simp only [w', w]; split
      exact isBounded_singleton
      apply IsBounded.subset Metric.isBounded_closedBall
      exact Set.inter_subset_right _ _
    constructor
    -- Prove v' n has small diameter
    . intro n; simp only [v, v']; split
      exact le_trans (le_of_eq Metric.diam_empty) (le_of_lt εpos)
      have : 0 ≤ ε/2 := by
        apply le_of_lt
        simp only [gt_iff_lt, Nat.ofNat_pos, div_pos_iff_of_pos_right]
        exact εpos
      have : Metric.diam (Metric.closedBall (D (Nat.unpair n).1 : α) (ε/2))
        ≤ ε := by
        apply le_trans (Metric.diam_closedBall this) _
        apply le_of_eq
        ring_nf
      apply le_trans _ this
      apply Metric.diam_mono
      apply _root_.subset_trans (Set.inter_subset_right _ _) _
      apply Metric.closedBall_subset_closedBall
      exact min_le_left _ _
      exact Metric.isBounded_closedBall
    constructor
    -- Prove w' n has small diameter
    . intro n; simp only [w, w']; split
      exact le_trans (le_of_eq Metric.diam_singleton) (le_of_lt εpos)
      have : 0 ≤ ε/2 := by
        apply le_of_lt
        simp only [gt_iff_lt, Nat.ofNat_pos, div_pos_iff_of_pos_right]
        exact εpos
      have : Metric.diam (Metric.closedBall (D (Nat.unpair n).2 : α) (ε/2))
        ≤ ε := by
        apply le_trans (Metric.diam_closedBall this) _
        apply le_of_eq
        ring_nf
      apply le_trans _ this
      apply Metric.diam_mono
      apply _root_.subset_trans (Set.inter_subset_right _ _) _
      apply Metric.closedBall_subset_closedBall
      exact min_le_left _ _
      exact Metric.isBounded_closedBall
    -- Prove v n ≠ w n
    intro n; simp only [v, v', w, w']; split
    . have := Set.singleton_nonempty x0
      exact (Set.Nonempty.ne_empty this).symm
    have : (D (Nat.unpair n).fst : α) ∉ u ∩ Metric.closedBall
      (D (Nat.unpair n).snd : α) (min (ε / 2) (1 / 3 *
      dist (D (Nat.unpair n).fst) (D (Nat.unpair n).snd))) := by
      intro hcont
      rw[Set.mem_inter_iff] at hcont
      rcases hcont with ⟨_, hcont⟩
      rw[Metric.mem_closedBall] at hcont
      have hcont' := le_trans hcont (min_le_right _ _)
      rw[dist_coer _ _] at hcont'
      rw[le_mul_iff_one_le_left] at hcont'
      norm_num at hcont'
      apply lt_of_le_of_ne
      exact dist_nonneg
      rw[ne_eq, eq_comm]; next h h2 => exact h
    rw[ne_eq, subset_antisymm_iff, not_and_or]
    apply Or.inl
    rw[Set.not_subset]
    use (D (Nat.unpair n).1)
    constructor
    apply Set.mem_inter
    simp only [Subtype.coe_prop]
    apply Metric.mem_closedBall_self _
    . apply le_min
      apply le_of_lt
      simp only [gt_iff_lt, Nat.ofNat_pos, div_pos_iff_of_pos_right]
      exact εpos
      simp only [one_div, gt_iff_lt, inv_pos, Nat.ofNat_pos,
        mul_nonneg_iff_of_pos_left, dist_nonneg]
    exact this

lemma decomp_of_sq_minus_diag {u : Set α} {ε : ENNReal} (uclosed : IsClosed u)
  (unonempty : Set.Nonempty u) (εpos : ε > 0)
  : ∃ v : ℕ → Set α, ∃ w : ℕ → Set α,
  sq_minus_diag u = ⋃ n : ℕ, v n ×ˢ w n
  ∧ (∀ n : ℕ, (v n) ⊆ u) ∧ (∀ n : ℕ, (w n) ⊆ u)
  ∧ (∀ n : ℕ, IsClosed (v n)) ∧ (∀ n : ℕ, IsClosed (w n))
  ∧ (∀ n : ℕ, EMetric.diam (v n) ≤ ε)
  ∧ (∀ n : ℕ, EMetric.diam (w n) ≤ ε)
  ∧ (∀ n : ℕ, v n ≠ w n)
  := by
    by_cases ε = ⊤
    . choose v w hdecomp vsub wsub vclosed wclosed _ _ _ _ hne using
      decomp_of_sq_minus_diag_u_real uclosed unonempty Real.zero_lt_one
      use v; use w
      next h _ _ _ _ =>
        rw[h]
        exact ⟨hdecomp, vsub, wsub, vclosed, wclosed, fun n => OrderTop.le_top (EMetric.diam (v n)),
          fun n => OrderTop.le_top (EMetric.diam (w n)), hne⟩
    have : ε.toReal > 0 := by
      next h =>
        refine ENNReal.toReal_pos ?ha₀ h
        exact ne_of_gt εpos
    choose v w hdecomp vsub wsub vclosed wclosed vbdd wbdd vdiam wdiam hne using
      decomp_of_sq_minus_diag_u_real uclosed unonempty this
    use v; use w
    next h =>
      have vdiam' : ∀ n : ℕ, EMetric.diam (v n) ≤ ε := by
        intro n
        rw[ediam_diam_aux]
        exact (ENNReal.ofReal_le_iff_le_toReal h).mpr (vdiam n)
        exact vbdd n
      have wdiam' : ∀ n : ℕ, EMetric.diam (w n) ≤ ε := by
        intro n
        rw[ediam_diam_aux]
        exact (ENNReal.ofReal_le_iff_le_toReal h).mpr (wdiam n)
        exact wbdd n
      exact ⟨hdecomp, vsub, wsub, vclosed, wclosed, vdiam', wdiam', hne⟩

/- Observation 2 : Given ε > 0, we can cover β by countably many many sets of
diameter ≤ 2ε -/
lemma localization {ε : ENNReal} (εpos : ε > 0)
  : ∃ v : ℕ → Set β, ⋃ n : ℕ, v n = Set.univ
  ∧ (∀ n : ℕ, EMetric.diam (v n) ≤ ε)
  ∧ ∀ n : ℕ, IsClosed (v n)
  := by
    by_cases h : Nonempty β
    choose D Ddense using exists_dense_seq β
    let v (n : ℕ) := EMetric.closedBall (D n) (ε/2)
    use v
    constructor
    . ext x; constructor
      intro _; trivial
      intro _
      simp only [DenseRange, Dense, EMetric.mem_closure_iff, gt_iff_lt,
        Set.mem_range, exists_exists_eq_and] at Ddense
      have : 0 < (ε/2) := by
        simp only [ENNReal.div_pos_iff, ne_eq, ENNReal.two_ne_top, not_false_eq_true, and_true]
        exact zero_lt_iff.mp εpos
      specialize Ddense x (ε/2) this
      cases' Ddense with a ha
      simp only[Set.mem_iUnion, EMetric.mem_closedBall]
      use a; exact le_of_lt ha
    constructor
    . intro n
      apply le_trans EMetric.diam_closedBall _
      rw[mul_comm, ENNReal.div_mul_cancel]
      exact two_ne_zero; exact ENNReal.two_ne_top
    intro n; exact EMetric.isClosed_ball
    rw[not_nonempty_iff] at h
    let v (_ : ℕ) : Set β := ∅
    use v
    simp only [Set.iUnion_empty, EMetric.diam_empty, zero_le, forall_const, isClosed_discrete,
      and_self, and_true, v]
    symm; rw[Set.univ_eq_empty_iff]; exact h

end Topology

/- At this point we assume that the σ-algebra of measurable sets on α and β are
in fact the Borel sets on α and β; we need this to know closed sets are
measurable -/
variable [BorelSpace α] [BorelSpace β] (fcont : Continuous f)

section SplittingLemma

open Classical Finset

/- Define a subtype of Finset (Set α) that captures the collection being
non-null and all sets in the collection being closed and pairwise disjoint -/
def P (f : α → β) := {F : Finset (Set α) // ¬IsNull f F ∧ (∀ s ∈ F, IsClosed s)
  ∧ (∀ s1 ∈ F, ∀ s2 ∈ F, s1 ≠ s2 → Disjoint s1 s2)}

/- Given such a collection, a specific set in that collection, and ε > 0, we
can split s into two closed disjoint subsets of diameter ≤ ε while keeping the
collection non-null -/
lemma splitting_one {H : P f} {u : Set α} (hu : u ∈ H.val) {ε : ENNReal}
  (εpos : ε > 0) : ∃ t1 t2, (IsClosed t1 ∧ t1 ⊆ u ∧ EMetric.diam t1 ≤ ε) ∧
  (IsClosed t2 ∧ t2 ⊆ u ∧ EMetric.diam t2 ≤ ε) ∧ Disjoint t1 t2 ∧
  ¬IsNull f (H.1 \ {u} ∪ {t1, t2}) := by
    choose v w hdecomp hvsub hwsub hvclosed hwclosed hvdiam hwdiam hdisj using
      decomp_of_sq_minus_diag (H.2.2.1 u hu) (nonempty_of_nonnull H.2.1 u hu) εpos
    have : ∃ n : ℕ, ¬IsNull f (H.1 \ {u} ∪ {v n, w n}) := by
      apply Classical.by_contradiction
      intro hcont; push_neg at hcont; apply H.2.1
      have vnin : ∀ n : ℕ, v n ∉ H.1 \ {u} := by
        intro n hcont; rw[mem_sdiff] at hcont
        have vnonempty := nonempty_of_nonnull H.2.1 (v n) hcont.1
        choose x hx using vnonempty
        have hxu := Set.mem_of_subset_of_mem (hvsub n) hx
        have unev : u ≠ v n := by
          rw[mem_singleton, ←ne_eq] at hcont
          exact (hcont.2).symm
        have uvdisj := H.2.2.2 u hu (v n) hcont.1 unev
        rw[Set.disjoint_iff_inter_eq_empty] at uvdisj
        have := Set.mem_inter hxu hx
        rw[uvdisj] at this
        contradiction
      have wnin : ∀ n : ℕ, w n ∉ H.1 \ {u} := by
        intro n hcont; rw[mem_sdiff] at hcont
        have wnonempty := nonempty_of_nonnull H.2.1 (w n) hcont.1
        choose x hx using wnonempty
        have hxu := Set.mem_of_subset_of_mem (hwsub n) hx
        have unew : u ≠ w n := by
          rw[mem_singleton, ←ne_eq] at hcont
          exact (hcont.2).symm
        have uwdisj := H.2.2.2 u hu (w n) hcont.1 unew
        rw[Set.disjoint_iff_inter_eq_empty] at uwdisj
        have := Set.mem_inter hxu hx
        rw[uwdisj] at this
        contradiction
      have unin : u ∉ H.1 \ {u} := by simp
      have eq : H.1 \ {u} ∪ {u} = H.1 := by
        simp_all only [ne_eq, gt_iff_lt, not_true, mem_singleton, union_insert,
          mem_union, mem_sdiff, not_and, not_not, and_false, not_false_eq_true,
          sdiff_union_self_eq_union, union_eq_left, singleton_subset_iff]
      rw[←eq]
      apply null_of_decomp_null (Continuous.measurable fcont)
        (IsClosed.measurableSet (H.2.2.1 u hu)) unin hdecomp vnin wnin hdisj _
        _ hcont
      intro n; exact IsClosed.measurableSet (hvclosed n)
      intro n; exact IsClosed.measurableSet (hwclosed n)
    rcases this with ⟨n, hn⟩
    use (v n); use (w n)
    constructor
    exact ⟨hvclosed n, hvsub n, hvdiam n⟩
    constructor
    exact ⟨hwclosed n, hwsub n, hwdiam n⟩
    constructor
    . have aux1 : v n ×ˢ w n ⊆ sq_minus_diag u := by
        rw[hdecomp]
        apply Set.subset_iUnion _ n
      simp only [sq_minus_diag, ne_eq] at aux1
      rw[Set.disjoint_iff_inter_eq_empty]
      ext x
      constructor
      . intro hx; exfalso
        rw[Set.mem_inter_iff] at hx
        have : (x,x) ∈ v n ×ˢ w n := by
          rw [Set.mem_prod]; exact hx
        have := Set.mem_of_subset_of_mem aux1 this
        simp only [Set.mem_setOf_eq, not_true, and_false] at this
      intro hx; contradiction
    exact hn

/- Given such a collection, any subset, and ε > 0, we can split all of the
members of the subset into small diameter pieces while leaving the rest
unchanged and keeping the collection non-null -/
lemma splitting_layer {H : P f} {Hs : Finset (Set α)} (hH : Hs ⊆ H.val)
  {ε : ENNReal} (εpos : ε > 0) : ∃ G : P f, (∀ s ∈ Hs, s ∉ G.1 ∧
  ∃ t1 t2, (t1 ∈ G.val ∧ t1 ⊆ s) ∧ (t2 ∈ G.val ∧ t2 ⊆ s) ∧ Disjoint t1 t2) ∧
  (∀ s ∈ H.val, s ∉ Hs → s ∈ G.val) ∧
  (∀ s ∈ G.val, s ∉ H.val → EMetric.diam s ≤ ε) := by
    set n := Hs.card with hn
    clear_value n
    induction' n with n ih generalizing Hs
    . symm at hn
      rw[Finset.card_eq_zero] at hn
      use H
      constructor
      . intro s hs
        rw[hn] at hs
        contradiction
      constructor
      . intro s hs _
        exact hs
      intro s hs hs'
      exfalso
      exact hs' hs
    symm at hn
    rw[Finset.card_eq_succ] at hn
    rcases hn with ⟨a, t, hnin, hins, hcard⟩
    have tsub : t ⊆ H.val := by
      apply subset_trans _ hH
      rw[←hins]
      apply Finset.subset_insert
    choose G hGsplit hGstay hGsmall using ih tsub hcard.symm
    have ain : a ∈ H.val := by
      apply Finset.mem_of_subset hH
      rw[←hins]
      exact Finset.mem_insert_self _ _
    have ain' : a ∈ G.val := by
      exact hGstay a ain hnin
    choose t1 t2 ht1 ht2 hdisj hnull using splitting_one fcont ain' εpos
    set G' := (G.val \ {a} ∪ {t1, t2}) with G'_def
    have G'closed : ∀ s ∈ G', IsClosed s := by
      intro s hs
      rw[G'_def] at hs
      simp only [Finset.mem_singleton, Finset.union_insert, Finset.mem_union,
        Finset.mem_sdiff, Finset.mem_insert] at hs
      rcases hs with hs | hs | hs
      . rw[hs]; exact ht1.1
      . apply G.2.2.1 s; exact hs.1
      rw[hs]; exact ht2.1
    have G'nonempty : ∀ s ∈ G', Set.Nonempty s := by
        intro s; exact nonempty_of_nonnull hnull s
    have G'disj : ∀ s1 ∈ G', ∀ s2 ∈ G', s1 ≠ s2 → Disjoint s1 s2 := by
      intro s1 hs1 s2 hs2 hn
      simp only [G', Finset.union_insert, ne_eq, Finset.mem_union, mem_sdiff,
        Finset.mem_singleton, Finset.mem_insert] at hs1 hs2
      rcases hs1 with hs1 | hs1 | hs1
      . rcases hs2 with hs2 | hs2 | hs2
        rw[hs1, hs2] at hn; contradiction
        . rw[hs1]
          apply Set.disjoint_of_subset_left ht1.2.1
          symm; exact G.2.2.2 s2 hs2.1 a ain' hs2.2
        rw[hs1, hs2]; exact hdisj
      . rcases hs2 with hs2 | hs2 | hs2
        . rw[hs2]
          apply Set.disjoint_of_subset_right ht1.2.1
          exact G.2.2.2 s1 hs1.1 a ain' hs1.2
        exact G.2.2.2 s1 hs1.1 s2 hs2.1 hn
        . rw[hs2]
          apply Set.disjoint_of_subset_right ht2.2.1
          exact G.2.2.2 s1 hs1.1 a ain' hs1.2
      . rcases hs2 with hs2 | hs2 | hs2
        rw[hs1, hs2]; exact hdisj.symm
        . rw[hs1]
          apply Set.disjoint_of_subset_left ht2.2.1
          symm; exact G.2.2.2 s2 hs2.1 a ain' hs2.2
        rw[hs1, hs2] at hn; contradiction
    use ⟨G', ⟨hnull, G'closed, G'disj⟩⟩
    constructor
    . intro s hs
      constructor
      . simp only [G', Finset.union_insert, Finset.mem_union, Finset.mem_sdiff,
          Finset.mem_singleton, Finset.mem_insert]
        push_neg
        rw[←hins, Finset.mem_insert] at hs
        constructor
        . rcases hs with hs | hs
          . rw[hs]
            intro hcont
            rw[hcont] at ht2
            rw[Set.disjoint_iff_inter_eq_empty] at hdisj
            have : t2 ∈ G' := by simp [G']
            choose x hx using G'nonempty t2 this
            have := Set.mem_of_subset_of_mem ht2.2.1 hx
            have := Set.mem_inter this hx
            rw[hdisj] at this
            contradiction
          have : s ∈ Hs := by
              rw [←hins, Finset.mem_insert]; apply Or.inr; exact hs
          have := Finset.mem_of_subset hH this
          apply Disjoint.ne
          . simp only [Set.bot_eq_empty]
            rw[←Set.nonempty_iff_ne_empty]
            apply nonempty_of_nonnull H.2.1 s _
            exact this
          apply Set.disjoint_of_subset_right ht1.2.1
          apply H.2.2.2 s this a ain
          intro hcont
          rw[hcont] at hs
          exact hnin hs
        constructor
        . intro hsG
          rcases hs with hs | hs
          exact hs
          exfalso
          exact (hGsplit s hs).1 hsG
        rcases hs with hs | hs
        . rw[hs]
          intro hcont
          rw[hcont] at ht1
          rw[Set.disjoint_iff_inter_eq_empty] at hdisj
          have : t1 ∈ G' := by simp [G']
          choose x hx using G'nonempty t1 this
          have := Set.mem_of_subset_of_mem ht1.2.1 hx
          have := Set.mem_inter hx this
          rw[hdisj] at this
          contradiction
        have : s ∈ Hs := by
            rw [←hins, Finset.mem_insert]; apply Or.inr; exact hs
        have := Finset.mem_of_subset hH this
        apply Disjoint.ne
        . rw [Set.bot_eq_empty, ←Set.nonempty_iff_ne_empty]
          apply nonempty_of_nonnull H.2.1 s _
          exact this
        apply Set.disjoint_of_subset_right ht2.2.1
        apply H.2.2.2 s this a ain
        intro hcont
        rw[hcont] at hs
        exact hnin hs
      simp only [← hins, Finset.mem_insert] at hs
      simp only [G', Finset.union_insert, ne_eq, Finset.mem_union,
        Finset.mem_sdiff, Finset.mem_singleton, Finset.mem_insert,
        exists_and_left]
      rcases hs with hs | hs
      . use t1
        constructor
        . simp only [true_or, true_and]
          rw[hs]; exact ht1.2.1
        use t2
        simp only [or_true, true_and]
        rw[hs]; exact ⟨ht2.2.1, hdisj⟩
      choose s1 s2 hs1 hs2 hdisj' using (hGsplit s hs).2
      use s1
      constructor
      . constructor
        apply Or.inr; apply Or.inl; constructor
        exact hs1.1
        . apply Disjoint.ne
          rw [Set.bot_eq_empty, ←Set.nonempty_iff_ne_empty]
          exact nonempty_of_nonnull G.2.1 s1 hs1.1
          apply Set.disjoint_of_subset_left hs1.2
          have := Finset.mem_of_subset tsub hs
          apply H.2.2.2 s this a ain
          intro hcont
          rw[hcont] at hs
          exact hnin hs
        exact hs1.2
      use s2
      constructor
      constructor
      apply Or.inr; apply Or.inl; constructor
      exact hs2.1
      . apply Disjoint.ne
        rw [Set.bot_eq_empty, ←Set.nonempty_iff_ne_empty]
        exact nonempty_of_nonnull G.2.1 s2 hs2.1
        apply Set.disjoint_of_subset_left hs2.2
        have := Finset.mem_of_subset tsub hs
        apply H.2.2.2 s this a ain
        intro hcont
        rw[hcont] at hs
        exact hnin hs
      exact hs2.2
      exact hdisj'
    constructor
    . intro s hsH hsHs
      simp only [G', Finset.union_insert, ne_eq, Finset.mem_union,
        Finset.mem_sdiff, Finset.mem_singleton, Finset.mem_insert]
      simp only [← hins, Finset.mem_insert] at hsHs
      push_neg at hsHs
      apply Or.inr; apply Or.inl; constructor
      exact hGstay s hsH hsHs.2
      exact hsHs.1
    intro s hsG' hsH
    simp only [G', Finset.union_insert, ne_eq, Finset.mem_union, Finset.mem_sdiff,
      Finset.mem_singleton, Finset.mem_insert] at hsG'
    rcases hsG' with hsG' | hsG' | hsG'
    rw[hsG']; exact ht1.2.2
    exact hGsmall s hsG'.1 hsH
    rw[hsG']; exact ht2.2.2

/- Given a small diameter collection, we can find subsets of each member to
preserve the required properties but have the image of the collection have a
small diameter -/
lemma refine_layer (H : P f) {ε : ENNReal} (εpos : ε > 0)
  (hsmall : ∀ s ∈ H.val, EMetric.diam s ≤ ε): ∃ G : P f,
  (∀ s ∈ H.val, ∃ t ∈ G.val, t ⊆ s) ∧ (∀ s ∈ G.val, EMetric.diam s ≤ ε) ∧
  EMetric.diam (f '' (⋃ s ∈ G.1, s)) ≤ ε := by
    choose v hvcover hvdiam hvclosed using @localization β _ _ _ εpos
    have aux : ∃ n : ℕ, ¬IsNull f ((H.1).image fun s => s ∩ f⁻¹' (v n)) := by
      apply Classical.by_contradiction
      intro hcont; push_neg at hcont
      apply H.2.1
      have vbcover : BorelCover v := by
        rw[BorelCover]; constructor
        exact hvcover
        intro n
        exact IsClosed.measurableSet (hvclosed n)
      apply null_of_localizations_null vbcover
      exact hcont
    choose n hn using aux
    set H' := (H.1).image (fun s => s ∩ f⁻¹' (v n))
    have H'closed : ∀ s ∈ H', IsClosed s := by
      intro s hs
      rw[Finset.mem_image] at hs
      rcases hs with ⟨a, ha, has⟩
      rw[←has]
      apply IsClosed.inter
      exact H.2.2.1 a ha
      apply IsClosed.preimage
      exact fcont
      exact hvclosed n
    have H'disj : ∀ s1 ∈ H', ∀ s2 ∈ H', s1 ≠ s2 → Disjoint s1 s2 := by
      intro s1 hs1 s2 hs2 hne
      rw[Finset.mem_image] at hs1 hs2
      rcases hs1 with ⟨a1, ha1, ha1s⟩
      rcases hs2 with ⟨a2, ha2, ha2s⟩
      have : a1 ≠ a2 := by
        intro hcont
        rw[←ha1s, ←ha2s, hcont] at hne
        contradiction
      have := H.2.2.2 a1 ha1 a2 ha2 this
      apply Set.disjoint_of_subset _ _ this
      rw[←ha1s]; apply Set.inter_subset_left
      rw[←ha2s]; apply Set.inter_subset_left
    use ⟨H', ⟨hn, H'closed, H'disj⟩⟩
    constructor
    . simp only [H', ne_eq, Finset.mem_image, exists_exists_and_eq_and]
      intro s hs; use s
      constructor; exact hs
      apply Set.inter_subset_left
    constructor
    . simp only [H', ne_eq, Finset.mem_image, forall_exists_index, and_imp,
        forall_apply_eq_imp_iff₂]
      intro s hs
      apply le_trans _ (hsmall s hs)
      apply EMetric.diam_mono
      apply Set.inter_subset_left
    simp only [H', ne_eq, Finset.mem_image, Set.iUnion_exists, Set.biUnion_and',
      Set.iUnion_iUnion_eq_right]
    apply le_trans _ (hvdiam n)
    apply EMetric.diam_mono
    apply subset_trans _ (Set.image_preimage_subset f (v n))
    apply Set.image_subset
    apply Set.iUnion_subset
    intro s
    apply Set.iUnion_subset
    intro _
    apply Set.inter_subset_right

/- Given a non-null collection, we can split it into another non-null
collection such that each member has two small-diameter children and the image
has small diameter -/
lemma splitting (H : P f) {ε : ENNReal} (εpos : ε > 0) : ∃ G : P f,
  (∀ s ∈ H.1, ∃ t1 t2, (t1 ∈ G.1 ∧ t1 ⊆ s) ∧ (t2 ∈ G.1 ∧ t2 ⊆ s) ∧
  Disjoint t1 t2) ∧ (∀ s ∈ G.1, EMetric.diam s ≤ ε) ∧
  EMetric.diam (f '' (⋃ s ∈ G.1, s)) ≤ ε := by
    choose G hGsplit _ hGsmall using splitting_layer
      fcont (Finset.Subset.refl H.1) εpos
    have hGsmall : ∀ s ∈ G.1, EMetric.diam s ≤ ε := by
      intro s hs
      specialize hGsmall s hs
      apply hGsmall
      intro hcont
      specialize hGsplit s hcont
      exact hGsplit.1 hs
    choose G2 hG2sub hG2indiam hG2outdiam using refine_layer fcont G εpos hGsmall
    use G2
    constructor
    . intro s hs
      specialize hGsplit s hs
      rcases hGsplit with ⟨_, t1, t2, ht1, ht2, hne⟩
      have aux1 := hG2sub t1 ht1.1
      have aux2 := hG2sub t2 ht2.1
      rcases aux1 with ⟨t'1, ht'1⟩
      rcases aux2 with ⟨t'2, ht'2⟩
      use t'1
      use t'2
      constructor
      . constructor
        exact ht'1.1
        exact subset_trans ht'1.2 ht1.2
      constructor
      . constructor
        exact ht'2.1
        exact subset_trans ht'2.2 ht2.2
      exact Set.disjoint_of_subset ht'1.2 ht'2.2 hne
    constructor
    . intro s hs
      exact hG2indiam s hs
    exact hG2outdiam

end SplittingLemma

section LusinNovikov

open CantorScheme Classical

/- To complete the proof, we need α to be a complete metric space -/
variable [cα : CompleteSpace α]

/- Lusin-Novikov: If univ is non-null (equiv, univ is not in I and thus cannot
be written as a countable union of Borel partial sections), then there exists a
continuous injection from the Cantor set into a single fiber of f -/
theorem exists_nat_bool_injection_fiber_of_univ_non_null
(hnonnull : ¬IsNull f {Set.univ}) : ∃ g : (ℕ → Bool) → α,
Continuous g ∧ Function.Injective g ∧ ∀ x y : ℕ → Bool, f (g x) = f (g y)
  := by
  obtain ⟨u, -, upos', hu⟩ :=
    exists_seq_strictAnti_tendsto' (zero_lt_one' ENNReal)
  have upos := fun n => (upos' n).1
  choose G hsplit hindiam houtdiam using
    fun (H : P f) {ε : ENNReal} (εpos : ε > 0) =>
    splitting fcont H εpos
  choose t0 t1 h0 h1 hdisj using
    fun (H : P f) {ε : ENNReal} (εpos : ε > 0) {s : Set α} (hs : s ∈ H.1) =>
    (hsplit H εpos) s hs
  let layer : ℕ → P f := fun n => by
    induction' n with n ih
    . exact ⟨{Set.univ}, ⟨hnonnull, by simp⟩⟩
    exact (G ih (upos n.succ))
  have layer_succ_def : ∀ n : ℕ, (layer n.succ) = (G (layer n) (upos n.succ))
    := by simp only [ne_eq, forall_const]
  let DP (l : List Bool) : {t : Set α // t ∈ (layer l.length).1} := by
    induction' l with a l ih
    . use Set.univ
      simp only [ne_eq, List.length_nil, Nat.rec_zero, Finset.mem_singleton, layer]
    cases a
    . use t0 (layer l.length) (upos l.length.succ) ih.2
      rw[List.length_cons, layer_succ_def l.length]
      exact (h0 _ _ _).1
    use t1 (layer l.length) (upos l.length.succ) ih.2
    rw[List.length_cons, layer_succ_def l.length]
    exact (h1 _ _ _).1
  let D (l : List Bool) : Set α := (DP l).val
  have hDin : ∀ l : List Bool, D l ∈ (layer (l.length)).1 := by
    simp only [ne_eq, Finset.coe_mem, forall_const, D, layer]
  have hanti : ClosureAntitone D := by
    apply Antitone.closureAntitone
    . intro l a
      cases a
      . exact (h0 _ _ _).2
      exact (h1 _ _ _).2
    intro l
    exact (layer l.length).2.2.1 (DP l).1 (DP l).2
  have hdiam : VanishingDiam D := by
    intro x
    apply tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds hu
    · simp only [zero_le, Filter.eventually_atTop, ge_iff_le,
      implies_true, forall_const,
        exists_const]
    rw [Filter.eventually_atTop]
    refine' ⟨1, fun m (hm : 1 ≤ m) => _⟩
    rw [Nat.one_le_iff_ne_zero] at hm
    rcases Nat.exists_eq_succ_of_ne_zero hm with ⟨n, rfl⟩
    cases x n
    · apply hindiam (layer n) (upos n.succ)
      convert hDin (PiNat.res x n.succ)
      rw[PiNat.res_length]
    apply hindiam (layer n) (upos n.succ)
    convert hDin (PiNat.res x n.succ)
    rw[PiNat.res_length]
  have hdisj' : CantorScheme.Disjoint D := by
    rintro l (a | a) (b | b) hab <;> try contradiction
    · exact hdisj _ _ _
    exact (hdisj _ _ _).symm
  have hdom : ∀ {x : ℕ → Bool}, x ∈ (inducedMap D).1 := fun {x} => by
    have : (inducedMap D).1 = Set.univ := by
      apply ClosureAntitone.map_of_vanishingDiam
      . exact hdiam
      . exact hanti
      intro l
      apply nonempty_of_nonnull (layer l.length).2.1
      exact hDin l
    rw[this]
    apply Set.mem_univ
  refine' ⟨fun x => (inducedMap D).2 ⟨x, hdom⟩, _, _, _⟩
  · apply hdiam.map_continuous.comp
    continuity
  . intro x y hxy
    simpa only [← Subtype.val_inj] using hdisj'.map_injective hxy
  intro x y
  apply eq_of_forall_edist_le
  intro ε hε
  have aux : ∃ n : ℕ, u n.succ ≤ ε := by
    rcases Filter.eventually_atTop.mp <|
      eventually_le_of_tendsto_lt hε hu with ⟨m, hm⟩
    exact ⟨m, hm _ m.le_succ⟩
  cases' aux with n hn
  have memx := map_mem ⟨x, hdom⟩ n.succ
  have memy := map_mem ⟨y, hdom⟩ n.succ
  apply le_trans _ hn
  apply le_trans _ (houtdiam (layer n) (upos n.succ))
  apply EMetric.edist_le_diam_of_mem
  . apply Set.mem_image_of_mem
    rw[Set.mem_iUnion]
    use D (PiNat.res x n.succ)
    rw[Set.mem_iUnion]
    have auxx := hDin (PiNat.res x n.succ)
    rw[PiNat.res_length] at auxx
    use auxx
  apply Set.mem_image_of_mem
  rw[Set.mem_iUnion]
  use D (PiNat.res y n.succ)
  rw[Set.mem_iUnion]
  have auxy := hDin (PiNat.res y n.succ)
  rw[PiNat.res_length] at auxy
  use auxy

end LusinNovikov
